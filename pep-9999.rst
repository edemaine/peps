PEP: 9999
Title: Unpacking in Comprehensions
Author: Erik Demaine <edemaine@mit.edu>, Adam Hartz <hz@mit.edu>
Sponsor: TBD
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 16-Oct-2021
Python-Version: 3.11
Post-History: 16-Oct-2021


Abstract
========

This PEP proposes extending list, set, and dict comprehensions, as
well as generator expressions, to allow unpacking notation (``*`` and
``**``) at the start of the expression.  For example,
``[*it for it in its]`` becomes short-hand for
``[x for it in its for x in it]``.
This notation makes it easy to combine an unknown number of iterables
(given by a ``for`` clause) into one list or set or generator, or an
unknown number of dictionaries into one dictionary.


Motivation
==========

Extended unpacking notation (``*`` and ``**``) from PEP 448 makes it
easy to combine a few iterables or dictionaries::

    [*it1, *it2, *it3]  # list with the concatenation of three iterables
    {*it1, *it2, *it3}  # set with the union of three iterables
    {**dict1, **dict2, **dict3}  # dict with the combination of three dicts
    # roughly equivalent to dict1 | dict2 | dict3 thanks to PEP 584

This PEP extends this pattern to enable combining an unknown number of
iterables or dictionaries, via comprehensions::

    [*it for it in its]  # list with the concatenation of iterables in 'its'
    {*it for it in its}  # set with the union of iterables in 'its'
    {**d for d in dicts} # dict with the combination of dicts in 'dicts'

In addition, it defines an analogous notation for generator expressions::

    (*it for it in its)  # generator of the concatenation of iterables in 'its'

The new notation listed above is effectively short-hand for the
following existing notation::

    [x for it in its for x in it]
    {x for it in its for x in it}
    {key: value for d in dicts for key, value in d.items()}
    (x for it in its for x in it)

(See below for a small difference for generator expressions.)

The new notation is more concise, avoiding the use and repetition of
auxiliary variables, and possibly more intuitive to programmers
familiar with both comprehensions and unpacking notation.  The
dictionary version can also probably be implemented more efficiently
by avoiding item tuple creation and unpacking.

Alternatively, the notation is effectively short-hand for the
following uses of ``itertools.chains``::

    list(itertools.chain(*its))
    set(itertools.chain(*its))
    dict(itertools.chain(*(d.items() for d in dicts)))
    itertools.chain(*its)

The use of ``*`` unpacking notation in these examples is in fact quite
similar to the proposed notation.  In the same way that
``[...x... for x in it]`` is effectively short-hand for
``list(...x... for x in it)``, the proposed notation enables use of
list comprehensions instead of the ``list`` constructor.


Rationale
=========

In the proposed notation, ``[*it for it in its]`` is analogous to
``[*its[0], *its[1], ..., *its[len(its)-1]]`` (pretending that ``its``
is a list so supports indexing) in the same way that
``[it for it in its]`` is analogous to
``[its[0], its[1], ..., its[len(its)-1]]``.
The same analogies holds for the set, dictionary, and generator
versions.

This notation was originally motivated by a written exam in a Python
programming class, where several students used the notation
(specifically the ``set`` version) in their solutions, assuming that
it already existed in Python.  This suggests that the notation is
intuitive, even to those who are learning Python.

An example where this notation is especially convenient (albeit
suboptimal in efficiency) is a recursive function that accumulates the
set of values from the leaves of a tree::

    def leaf_values(node):
        if node.children:
            return {*leaf_values(child) for child in node.children}
        else:
            return {node.value}


Specification
=============

In the grammar, the rules for comprehensions and generator expressions
would use ``star_named_expression`` instead of ``named_expression``,
and ``double_starred_kvpair`` instead of ``kvpair``::

    listcomp:
        | '[' star_named_expression for_if_clauses ']'
    setcomp:
        | '{' star_named_expression for_if_clauses '}'
    dictcomp:
        | '{' double_starred_kvpair for_if_clauses '}'
    genexp:
        | '(' star_named_expression for_if_clauses ')'

(Small note: the current rule for ``genexp`` uses
``( assigment_expression | expression !':=')`` but this is equivalent to
``named_expression``.)

The meaning of a starred expression in a list comprehension
``[*expr for x in it]`` is to treat each expression as an iterable, and
concatenate them, in the same way as if they were explicitly listed
via ``[*expr1, *expr2, ...]``.  Similarly, ``{*expr for x in it}``
forms a set union, as if the expressions were explicited listed via
``{*expr1, *expr2, ...}``; and ``{**expr for x in it}`` combines
dictionaries, as if the expressions were explicitly listed via
``{**expr1, **expr2, ...}``.  As usual with sets and dictionaries,
repeated elements/keys replace earlier instances.

In normal circumstances, the generator expression ``(*expr for x in
it)`` forms a generator producing the concatenation of the iterables
given by the expressions.  To enable delegation to subgenerators, this
generator has a ``send`` method that passes values on to the individual
iterable currently being processed.  Specifically, the behavior is
defined to be equivalent to the following generator::

    def generator():
        for x in it:
            yield from expr

(This is a difference from ``itertools.chain``, whose returned
iterator lacks a ``send`` method, but natural given that this is a
generator expression and thus should work like a generator.)


Backwards Compatibility
=======================

The proposed notation currently generates a ``SyntaxError`` (via the
``invalid_comprehension`` and ``invalid_dict_comprehension`` rules in
the CPython grammar).


How to Teach This
=================

Previously, ``out = [...x... for x in it]`` could be thought of as
equivalent to the following code::

    out = []
    for x in it:
        out.append(...x...)

This equivalence no longer holds when we allow ``*x`` in place of
``...x...``, because ``list.append`` accepts only a single argument.

With the new syntax, we can instead think of
``out = [...x... for x in it]`` (whether or not it uses a ``*``)
as equivalent to the following code [#guido]_::

    out = []
    for x in it:
        out.extend([...x...])

Similarly, we can think of ``out = {...x... for x in it}`` (whether or
not it uses a ``*`` or a ``**`` or a ``:``) as equivalent to the
following code::

    out = set()
    for x in it:
        out.update({...x...})

Finally, we can think of ``out = (*...x... for x in it)``
(specifically the version that uses a ``*``) as equivalent to the
following code::

    def generator():
        for x in it:
            yield from ...x...
    out = generator()


Rejected Ideas
==============

Originally, it seemed natural to introduce an unbounded version of
the existing tuple unpacking notation::

    (*it1, *it2, *it3)  # tuple with the concatenation of three iterables

Specifically, the following notation would be symmetric to the proposed
notation for lists, sets, dictionaries, and generators::

    (*it for it in its)  # tuple with the concatenation of iterables in 'its'

However, this case is not symmetric, because ``(it for it in its)`` is
not a tuple comprehension; rather, it is a generator expression.
Hence the proposal to make the generator expression symmetric with
list comprehensions.

Similarly, it seemed natural to define an unbounded version of the
existing argument unpacking notation::

    f(*it1, *it2, *it3)  # pass arguments from three iterables

Specifically, it would be symmetric to define the following::

    f(*expr for it in its)  # pass arguments from iterables in 'its'

to be equivalent to ``f(*expr1, *expr2, ...)``.  However, this
notation would be inconsistent with the current behavior of
``f(expr for it in its)``, which passes a single argument (a
generator) into ``f``.  (While PEP 289 requires parentheses
around a generator expression, it explicitly allows these parentheses
to be the same parentheses that make a a single-argument function
call.)  To accomplish ``f(*expr1, *expr2, ...)`` with the new notation
from this PEP, we can write ``f(*(*expr for it in its))``.  This is
parallel to how current Python supports ``f(*(expr for x in it))``.


References
==========

.. [#guido] Message from Guido van Rossum
   (https://mail.python.org/archives/list/python-ideas@python.org/message/CQPULNM6PM623PLXF5Z63BIUZGOSQEKW/)


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
